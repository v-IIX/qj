using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SingletonPattern
{
  /// <summary>
  /// 单例模式：保证进程中某个类只有一个实例（某些类占用大量资源，不适合多次实例化）
  /// 如何强制保证一个类只有一个实例？
  ///   1 构造函数私有化（关闭对象的外部创建权限）
  ///   2 申明静态字段
  ///   3 类内部提供公开的静态方法用于提供实例
  ///  
  /// 为什么要使用单例？
  ///   单例不是为了解决线程冲突！！！
  ///   单例只是为了有一个实例(如静态字典、数据库连接池、线程池、IOC容器实例)
  ///   
  /// 单例模式会长期持有一个对象，不会释放；普通实例使用完后就释放
  /// 
  /// 单例模式：把对象的创建权限关闭，提供一个公开的静态方法，起到对象重用
  /// 原型模式：把对象的创建权限关闭，提供一个公开的静态方法，提供全新的对象，不是走的构造函数
  /// 
  /// 三大工厂：
  ///   1 简单工厂:把对象的创建方法集中到一起
  ///   2 工厂方法：把创建对象工厂拆分开，一个工厂只做一件事
  ///   3 抽象工厂：创建多个对象
  /// 
  /// </summary>
  class Program
  {
    static void Main(string[] args)
    {
    }
  }
}
